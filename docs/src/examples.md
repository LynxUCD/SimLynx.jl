```@meta
    # NOTE this file is autogenerated, do not edit examples.md directly. To make an example, upload the .jl file to the examples folder. Header comments may be included at the top of the file using """ syntax
``` 
# Examples
Below are some useful examples to give you an idea of how this package can be leveraged. The code for these examples can also be found on Github
 in the `docs/examples` folder.

## Closed-Loop-Bank-Model
```julia
# closed-loop-bank-model.jl
# SimLynx.jl Example Closed-Loop Monte Carlo Model

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

const N_TELLERS = 2
const MEAN_INTERARRIVAL_TIME = 4.0
const MIN_SERVICE_TIME = 2.0
const MAX_SERVICE_TIME = 10.0

tellers = nothing

"Process to generate n customers arriving into the system."
@process generator(n::Integer) begin
    dist = Exponential(MEAN_INTERARRIVAL_TIME)
    for i = 1:n
        @schedule now customer(i)
        # We don't want to wait after the last customer, which could extend the
        # simulation time past the last customer leaving.
        if i < n
            work(rand(dist))
        end
    end
end

"The ith customer into the system."
@process customer(i::Integer) begin
    dist = Uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
    @with_resource tellers begin
        work(rand(dist))
    end
end

"Run the simulation for n customers."
function run_simulation(n1::Integer, n2::Integer)
    @assert n1 > 0 && n2 > 0
    println("SimLynx Closed Loop Processing Example")
    println("Number of runs = $n1, number of customers = $n2")
    println("Single Queue, $N_TELLERS Teller Bank Model")
    @simulation begin
        avg_tellers = Variable{Float64}(data=:tally, history=true)
        max_tellers = Variable{Int64}(data=:tally, history=true)
        for i = 1:n1
            @simulation begin
                global tellers = Resource("tellers")
                @schedule at 0.0 generator(n2)
                start_simulation()
                avg_tellers.value = tellers.allocated.stats.mean
                max_tellers.value = tellers.allocated.stats.max
            end
        end
        print_stats(avg_tellers, title="Average Tellers Statistics")
        plot_history(avg_tellers, title="Average Tellers History")
        print_stats(max_tellers, title="Maximum Tellers Statistics")
        plot_history(max_tellers, title="Maximum Tellers History")
    end
end

run_simulation(10_000, 100)

```
## Event-Based-Bank-Model
```julia
# event-based-bank.model.jl
# SimLynx.jl Event-Based Discrete-Event Simulation Example

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

const N_TELLERS = 2
const MEAN_INTERARRIVAL_TIME = 4.0
const MIN_SERVICE_TIME = 2.0
const MAX_SERVICE_TIME = 10.0

struct Customer
    id::Int64
    Customer(id::Int64) = new(id)
end

Base.show(io::IO, customer::Customer) =
    print(io, "Customer($(customer.id))")

mutable struct Teller
    id::Int64
    serving::Union{Customer, Nothing}
    Teller(id::Int64) = new(id, nothing)
end

Base.show(io::IO, teller::Teller) =
    print(io, "Teller($(teller.id))")

tellers = nothing
teller_queue = nothing

function available_teller()::Union{Teller, Nothing}
    for teller in tellers
        if isnothing(teller.serving)
            return teller
        end
    end
    return nothing
end

generator_dist = Exponential(MEAN_INTERARRIVAL_TIME)

@event generate(i:: Integer, n::Integer) begin
    @schedule now arrival(Customer(i))
    if i < n
        @schedule in rand(generator_dist) generate(i + 1, n)
    end
end

@event arrival(customer::Customer) begin
    teller = available_teller()
    if isnothing(teller)
        enqueue!(teller_queue, customer)
    else
        @schedule now service(teller, customer)
    end
end

@event service(teller::Teller, customer::Customer) begin
    dist = Uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
    teller.serving = customer
    @schedule in rand(dist) departure(teller, customer)
end

@event departure(teller::Teller, customer::Customer) begin
    if isempty(teller_queue)
        teller.serving = nothing
    else
        next_customer = dequeue!(teller_queue)
        teller.serving = next_customer
        @schedule now service(teller, next_customer)
    end
end

function run_simulation(n::Integer)
    @assert n > 0
    println("SimLynx.jl Event-Based Discrete-Event Simulation Example")
    println("$N_TELLERS Teller, Single Queue Bank Model")
    println("  Inter-arrival time = Exponential($MEAN_INTERARRIVAL_TIME)")
    println("  Service time = Uniform($MIN_SERVICE_TIME, $MAX_SERVICE_TIME)")
    println("  Number of customers = $n")
    @simulation begin
        global tellers = [Teller(i) for i = 1:N_TELLERS]
        global teller_queue = FifoQueue{Customer}()
        @schedule at 0.0 generate(1, n)
        start_simulation()
        print_stats(teller_queue.n, title="Teller Queue Length Statistics")
        plot_history(teller_queue.n, title="Teller Queue Length History")
    end
end

run_simulation(100)

```
## Harbor-Model
```julia
# harbor-model.jl
# SimLynx.jl Harbor Model

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

const MEAN_INTERARRIVAL_TIME = 4.0 / 3.0 # days
const MIN_UNLOADING_TIME = 1.0 # days
const MAX_UNLOADING_TIME = 2.5 # days

cycle_time = nothing

dock = nothing
queue = nothing

@process scheduler() begin
    dist = Exponential(MEAN_INTERARRIVAL_TIME)
    i = 1
    while true
        @schedule in 0.0 ship(i)
        work(rand(dist))
        i += 1
    end
end

@process ship(i::Integer) begin
    dist = Uniform(MIN_UNLOADING_TIME, MAX_UNLOADING_TIME)
    arrival_time = current_time()
    current_process_store!(:unloading_time, rand(dist))
    if !harbor_master(current_process(), :arriving)
        enqueue!(queue, current_process())
        suspend()
    end
    work(current_process_store(:unloading_time))
    remove!(dock, current_process())
    cycle_time.value = current_time() - arrival_time
    harbor_master(current_process(), :leaving)
    return nothing
end

function harbor_master(ship::Process, action::Symbol)
    if action == :arriving
        if length(dock) < 2
            # The dock is not full
            if isempty(dock)
                process_store!(ship,
                               :unloading_time,
                               process_store(ship, :unloading_time) / 2)
            else
                other_ship = first(dock)
                notice = interrupt(other_ship)
                notice.time = current_time() + 2*notice.time
                resume(other_ship, notice)
            end
            add!(dock, ship)
            return true
        else
            # The dock is full
            return false
        end
    elseif action == :leaving
        if isempty(queue)
            if !isempty(dock)
                other_ship = first(dock)
                notice = interrupt(other_ship)
                notice.time = current_time() + 2/notice.time
                resume(other_ship, notice)
            end
        else
            next_ship = dequeue!(queue)
            enqueue!(dock, next_ship)
            resume(next_ship, Notice(current_time(), next_ship))
        end
        return true
    else
        error("harbor_master: illegal action value $action")
    end
end

@event stop_sim() begin
    println("Harbor Model - report after $(current_time()) days - $(cycle_time.stats.n) ships unloaded")
    println("Minimum unload time was $(cycle_time.stats.min)")
    println("Maximum unload time was $(cycle_time.stats.max)")
    println("Average unload time was $(cycle_time.stats.mean)")
    println("Average queue of ships waiting to be unloaded was $(queue.n.stats.mean)")
    println("Maximum queue of ships waiting to be unloaded was $(queue.n.stats.max)")
    plot_history(queue.n, title="Queue of Ships History")
    stop_simulation()
end

function run_simulation()
    @simulation begin
        # current_trace!(true)
        global cycle_time = Variable{Float64}(data=:tally)
        global dock = Queue{Process}()
        global queue = FifoQueue{Process}()
        @schedule at 0.0 scheduler()
        @schedule at 80.0 stop_sim()
        start_simulation()
    end
end

run_simulation()

```
## Mixed-Event-Process-Based-Bank-Model
```julia
# mixed-event-process-based-bank-model.jl
# SimLynx.jl Mixed Event and Process Based Simulation Model

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

const N_TELLERS = 2
const MEAN_INTERARRIVAL_TIME = 4.0
const MIN_SERVICE_TIME = 2.0
const MAX_SERVICE_TIME = 10.0

tellers = nothing

generator_dist = Exponential(MEAN_INTERARRIVAL_TIME)

"Generate the ith customer and schedule the next arrival."
@event generate(i:: Integer, n::Integer) begin
    @schedule now customer(i)
    if i < n
        @schedule in rand(generator_dist) generate(i + 1, n)
    end
end

"The ith customer into the system."
@process customer(i::Integer) begin
    dist = Uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
    @with_resource tellers begin
        work(rand(dist))
    end
end

"Run the simulation."
function run_simulation(n::Integer)
    @assert n > 0
    println("SimLynx Mixed Event and Process Based Simulation Example")
    println("$N_TELLERS Teller, Single Queue Bank Model")
    println("  Inter-arrival time = Exponential($MEAN_INTERARRIVAL_TIME)")
    println("  Service time = Uniform($MIN_SERVICE_TIME, $MAX_SERVICE_TIME)")
    println("  Number of customers = $n")
    @simulation begin
        global tellers = Resource(N_TELLERS, "tellers")
        @schedule at 0.0 generate(1, n)
        start_simulation()
        print_stats(tellers.allocated, title="Allocated Statistics")
        print_stats(tellers.queue_length, title="Queue Length Statistics")
        plot_history(tellers.queue_length, title="Queue Length History")
    end
end

run_simulation(100)

```
## Nested-Simulations
```julia
# nested-simulations.jl
# SimLynx Nested Simulation Environments Example

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

const N_TELLERS = 2
const MEAN_INTERARRIVAL_TIME = 4.0
const MIN_SERVICE_TIME = 2.0
const MAX_SERVICE_TIME = 10.0

tellers = nothing

"Process to generate n customers arriving into the system."
@process generator(n::Integer) begin
    dist = Exponential(MEAN_INTERARRIVAL_TIME)
    for i = 1:n
        @schedule now customer(i)
        # We don't want to wait after the last customer, which could extend the
        # simulation time past the last customer leaving.
        if i < n
            work(rand(dist))
        end
    end
end

"The ith customer into the system."
@process customer(i::Integer) begin
    dist = Uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
    @with_resource tellers begin
        work(rand(dist))
    end
end

"Run the simulation for n customers."
function run_simulation(n1::Integer, n2::Integer)
    @assert n1 > 0 && n2 > 0
    println("SimLynx Nested Simulation Environments Example")
    println("Number of runs = $n1, number of customers = $n2")
    println("Single Queue, $N_TELLERS Teller Bank Model")
    @simulation begin
        for i = 1:n1
            @simulation begin
                global tellers = Resource(N_TELLERS, "tellers")
                @schedule at 0.0 generator(n2)
                start_simulation()
                print_stats(tellers.allocated, title="Allocated Statistics")
                print_stats(tellers.queue_length, title="Queue Length Statistics")
                plot_history(tellers.queue_length, title="Queue Length History")
                print_stats(tellers.wait, title="Queue Wait Statistics")
            end
        end
    end
end

run_simulation(10, 100)

```
## Open-Loop-Bank-Model
```julia
# open-loop-bank-model.jl
# SimLynx Open Loop Processing Example

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

const N_TELLERS = 2
const MEAN_INTERARRIVAL_TIME = 4.0
const MIN_SERVICE_TIME = 2.0
const MAX_SERVICE_TIME = 10.0

"Process to generate n customers arriving into the system."
@process generator(n::Integer) begin
    dist = Exponential(MEAN_INTERARRIVAL_TIME)
    for i = 1:n
        @schedule now customer(i)
        # We don't want to wait after the last customer, which could extend the
        # simulation time past the last customer leaving.
        if i < n
            work(rand(dist))
        end
    end
end

"The ith customer into the system."
@process customer(i::Integer) begin
    dist = Uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
    @with_resource tellers begin
        work(rand(dist))
    end
end

"Run the simulation for n customers."
function run_simulation(n1::Integer, n2::Integer)
    @assert n1 > 0 && n2 > 0
    println("SimLynx Open Loop Processing Example")
    println("Number of runs = $n1, number of customers = $n2")
    println("Single Queue, $N_TELLERS Teller Bank Model")
    @simulation begin
        avg_wait = Variable{Float64}(data=:tally, history=true)
        for i = 1:n1
            @simulation begin
                global tellers = Resource(N_TELLERS, "tellers")
                @schedule at 0.0 generator(n2)
                start_simulation()
                avg_wait.value = tellers.wait.stats.mean
            end
        end
        print_stats(avg_wait, title="Average Wait Statistics")
        plot_history(avg_wait, title="Average Wait History")
    end
end

run_simulation(10_000, 100)

```
## Process-Based-Bank-Model
```julia
# process-based-bank-model.jl
# SimLynx.jl Process-Based Discrete-Event Simulation Example

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

const N_TELLERS = 2
const MEAN_INTERARRIVAL_TIME = 4.0
const MIN_SERVICE_TIME = 2.0
const MAX_SERVICE_TIME = 10.0

tellers = nothing

"Process to generate n customers arriving into the system."
@process generator(n::Integer) begin
    dist = Exponential(MEAN_INTERARRIVAL_TIME)
    for i = 1:n
        @schedule now customer(i)
        # We don't want to wait after the last customer, which could extend the
        # simulation time past the last customer leaving.
        if i < n
            work(rand(dist))
        end
    end
end

"The ith customer into the system."
@process customer(i::Integer) begin
    dist = Uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
    @with_resource tellers begin
        work(rand(dist))
    end
end

"Run the simulation for n customers."
function run_simulation(n::Integer)
    @assert n > 0
    println("SimLynx.jl Process-Based Discrete-Event Simulation Example")
    println("$N_TELLERS Teller, Single Queue Bank Model")
    println("  Inter-arrival time = Exponential($MEAN_INTERARRIVAL_TIME)")
    println("  Service time = Uniform($MIN_SERVICE_TIME, $MAX_SERVICE_TIME)")
    println("  Number of customers = $n")
    @simulation begin
        global tellers = Resource(N_TELLERS, "tellers")
        @schedule at 0.0 generator(n)
        start_simulation()
        println("--- Simulation results after $(current_time()) minutes ---")
        print_stats(tellers.allocated, title="Teller Allocation Statistics")
        print_stats(tellers.queue_length, title="Teller Queue Length Statistics")
        plot_history(tellers.queue_length, title="Teller Queue Length History")
        print_stats(tellers.wait, title="Teller Queue Wait Time Statistics")
        plot_history(tellers.wait, title="Teller Queue Wait Time History")
    end
end

run_simulation(100)

```
## Repeatable-Closed-Loop-Bank-Model
```julia
# closed-loop-bank-model.jl
# Example Repeatable Closed-Loop Monte Carlo Model

#=
This is an example on a closed-loop simulation model. This example gathers
statistics on the maximum number of tellers needed for no customer waiting.
=#

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

const N_TELLERS = 2
const MEAN_INTERARRIVAL_TIME = 4.0
const MIN_SERVICE_TIME = 2.0
const MAX_SERVICE_TIME = 10.0

run_number = 0
const GENERATOR_RNG = 1
const CUSTOMER_RNG = 2

"Process to generate n customers arriving into the system."
@process generator(n::Integer) begin
    rng = MersenneTwister(seed(run_number, GENERATOR_RNG))
    dist = Exponential(MEAN_INTERARRIVAL_TIME)
    for i = 1:n
        @schedule now customer(i)
        # We don't want to wait after the last customer, which could extend the
        # simulation time past the last customer leaving.
        if i < n
            work(rand(rng, dist))
        end
    end
end

"The ith customer into the system."
@process customer(i::Integer) begin
    rng = MersenneTwister(seed(run_number, CUSTOMER_RNG, i))
    dist = Uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
    @with_resource tellers begin
        work(rand(rng, dist))
    end
end

"Run the simulation for n customers."
function run_simulation(n1::Integer, n2::Integer)
    @assert n1 > 0 && n2 > 0
    println("SimLynx Repeatable Closed Loop Processing Example")
    println("Number of runs = $n1, number of customers = $n2")
    println("Single Queue, $N_TELLERS Teller Bank Model")
    @simulation begin
        avg_tellers = Variable{Float64}(data=:tally, history=true)
        max_tellers = Variable{Int64}(data=:tally, history=true)
        for i = 1:n1
            global run_number = i
            @simulation begin
                global tellers = Resource("tellers")
                @schedule at 0.0 generator(n2)
                start_simulation()
                avg_tellers.value = tellers.allocated.stats.mean
                max_tellers.value = tellers.allocated.stats.max
            end
        end
        print_stats(avg_tellers, title="Average Tellers Statistics")
        plot_history(avg_tellers, title="Average Tellers History")
        print_stats(max_tellers, title="Maximum Tellers Statistics")
        plot_history(max_tellers, title="Maximum Tellers History")
    end
end

run_simulation(10_000, 100)

```
## Repeatable-Event-Based-Bank-Model
```julia
# SimLynx.jl Event-Based Discrete-Event Simulation Example

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

const N_TELLERS = 2
const MEAN_INTERARRIVAL_TIME = 4.0
const MIN_SERVICE_TIME = 2.0
const MAX_SERVICE_TIME = 10.0

const GENERATOR_RNG = 1
const CUSTOMER_RNG = 2

struct Customer
    id::Int64
    rng::MersenneTwister
    Customer(id::Int64) = new(id, MersenneTwister(seed(CUSTOMER_RNG, id)))
end

Base.show(io::IO, customer::Customer) =
    print(io, "Customer($(customer.id))")

mutable struct Teller
    id::Int64
    serving::Union{Customer, Nothing}
    Teller(id::Int64) = new(id, nothing)
end

Base.show(io::IO, teller::Teller) =
    print(io, "Teller($(teller.id))")

tellers = nothing
teller_queue = nothing

function available_teller()::Union{Teller, Nothing}
    for teller in tellers
        if isnothing(teller.serving)
            return teller
        end
    end
    return nothing
end

generator_rng = MersenneTwister(seed(GENERATOR_RNG))
generator_dist = Exponential(MEAN_INTERARRIVAL_TIME)

@event generate(i:: Integer, n::Integer) begin
    @schedule now arrival(Customer(i))
    if i < n
        @schedule in rand(generator_rng, generator_dist) generate(i + 1, n)
    end
end

@event arrival(customer::Customer) begin
    teller = available_teller()
    if isnothing(teller)
        enqueue!(teller_queue, customer)
    else
        @schedule now service(teller, customer)
    end
end

service_dist = Uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)

@event service(teller::Teller, customer::Customer) begin
    teller.serving = customer
    @schedule in rand(customer.rng, service_dist) departure(teller, customer)
end

@event departure(teller::Teller, customer::Customer) begin
    if isempty(teller_queue)
        teller.serving = nothing
    else
        next_customer = dequeue!(teller_queue)
        teller.serving = next_customer
        @schedule now service(teller, next_customer)
    end
end

function run_simulation(n::Integer)
    @assert n > 0
    println("SimLynx.jl Repeatable Event-Based Discrete-Event Simulation Example")
    println("$N_TELLERS Teller, Single Queue Bank Model")
    println("  Inter-arrival time = Exponential($MEAN_INTERARRIVAL_TIME)")
    println("  Service time = Uniform($MIN_SERVICE_TIME, $MAX_SERVICE_TIME)")
    println("  Number of customers = $n")
    @simulation begin
        global tellers = [Teller(i) for i = 1:N_TELLERS]
        global teller_queue = FifoQueue{Customer}()
        @schedule at 0.0 generate(1, n)
        start_simulation()
        print_stats(teller_queue.n, title="Teller Queue Length Statistics")
        plot_history(teller_queue.n, title="Teller Queue Length History")
    end
end

run_simulation(100)

```
## Repeatable-Open-Loop-Bank-Model
```julia
# example-4.jl
# Example nested simulation models with data collection

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

const N_TELLERS = 2
const MEAN_INTERARRIVAL_TIME = 4.0
const MIN_SERVICE_TIME = 2.0
const MAX_SERVICE_TIME = 10.0

run_number = 0
const GENERATOR_RNG = 1
const CUSTOMER_RNG = 2

"Process to generate n customers arriving into the system."
@process generator(n::Integer) begin
    rng = MersenneTwister(seed(run_number, GENERATOR_RNG))
    dist = Exponential(MEAN_INTERARRIVAL_TIME)
    for i = 1:n
        work(rand(rng, dist))
        @schedule now customer(i)
    end
end

"The ith customer into the system."
@process customer(i::Integer) begin
    rng = MersenneTwister(seed(run_number, CUSTOMER_RNG, i))
    dist = Uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
    @with_resource tellers begin
        work(rand(rng, dist))
    end
end

"Run the simulation for n customers."
function run_simulation(n1::Integer, n2::Integer)
    println("SimLynx Repeatable Open Loop Processing Example")
    println("Number of runs = $n1, number of customers = $n2")
    println("Single Queue, $N_TELLERS Teller Bank Model")
    @simulation begin
        avg_wait = Variable{Float64}(data=:tally, history=true)
        for i = 1:n1
            global run_number = i
            @simulation begin
                global tellers = Resource(N_TELLERS, "tellers")
                @schedule at 0.0 generator(n2)
                start_simulation()
                avg_wait.value = tellers.wait.stats.mean
            end
        end
        print_stats(avg_wait, title="Average Wait Statistics")
        plot_history(avg_wait, title="Average Wait History")
    end
end

run_simulation(10_000, 100)

```
## Repeatable-Process-Based-Bank-Model
```julia
# SimLynx.jl Repeatable Process-Based Discrete-Event Simulation Example

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

const N_TELLERS = 2
const MEAN_INTERARRIVAL_TIME = 4.0
const MIN_SERVICE_TIME = 2.0
const MAX_SERVICE_TIME = 10.0

const GENERATOR_RNG = 1
const CUSTOMER_RNG = 2

tellers = nothing

"Process to generate n customers arriving into the system."
@process generator(n::Integer) begin
    rng = MersenneTwister(seed(GENERATOR_RNG))
    dist = Exponential(MEAN_INTERARRIVAL_TIME)
    for i = 1:n
        @schedule now customer(i)
        work(rand(rng, dist))
    end
end

"The ith customer into the system."
@process customer(i::Integer) begin
    rng = MersenneTwister(seed(CUSTOMER_RNG, i))
    dist = Uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
    @with_resource tellers begin
        work(rand(rng, dist))
    end
end

"Run the simulation for n customers."
function run_simulation(n::Integer)
    println("SimLynx.jl Repeatable Process-Based Discrete-Event Simulation Example")
    println("$N_TELLERS Teller, Single Queue Bank Model")
    println("  Inter-arrival time = Exponential($MEAN_INTERARRIVAL_TIME)")
    println("  Service time = Uniform($MIN_SERVICE_TIME, $MAX_SERVICE_TIME)")
    println("  Number of customers = $n")
    @simulation begin
        global tellers = Resource(N_TELLERS, "tellers")
        @schedule at 0.0 generator(n)
        start_simulation()
        println("--- Simulation results after $(current_time()) minutes ---")
        print_stats(tellers.allocated, title="Teller Allocation Statistics")
        print_stats(tellers.queue_length, title="Teller Queue Length Statistics")
        plot_history(tellers.queue_length, title="Teller Queue Length History")
        print_stats(tellers.wait, title="Teller Queue Wait Time Statistics")
        plot_history(tellers.wait, title="Teller Queue Wait Time History")
    end
end

run_simulation(100)

```
## Simple-Send-Accept-With-Argument
```julia
# Simple Send and Accept with Arguments

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

@process lock() begin
    while true
        @accept caller lock(i::Integer) begin
            println("locked for p1($i)")
        end
        @accept caller unlock()
    end
end

the_lock = Nothing

@process p1(i::Integer) begin
    println("$(current_time()): Process p1($i) started")
    @send the_lock lock(i)
    println("$(current_time()): Process p1($i) acquired lock")
    work(rand(Uniform(1.0, 10.0)))
    println("$(current_time()): Process p1($i) released lock")
    @send the_lock unlock()
    println("$(current_time()): Process p1($i) ended")
end

function run_simulation(n::Integer)
    @simulation begin
        # current_trace!(true)
        global the_lock = @schedule now lock()
        for i = 1:n
            @schedule at rand(Uniform(0.0, 10.0)) p1(i)
        end
        start_simulation()
    end
end

run_simulation(10)

```
## Simple-Send-Accept-With-Return-Value
```julia
# Simple Send and Accept with Return Value

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

@process lock() begin
    while true
        @accept caller lock(i::Integer) begin
            return "locked for p1($i)"
        end
        @accept caller unlock()
    end
end

the_lock = Nothing

@process p1(i::Integer) begin
    println("$(current_time()): Process p1($i) started")
    let msg = @send the_lock lock(i)
        println("msg = $msg")
    end
    println("$(current_time()): Process p1($i) acquired lock")
    work(rand(Uniform(1.0, 10.0)))
    println("$(current_time()): Process p1($i) released lock")
    @send the_lock unlock()
    println("$(current_time()): Process p1($i) ended")
end

function run_simulation(n::Integer)
    @simulation begin
        # current_trace!(true)
        global the_lock = @schedule now lock()
        for i = 1:n
            @schedule at rand(Uniform(0.0, 10.0)) p1(i)
        end
        start_simulation()
    end
end

run_simulation(10)

```
## Simple-Send-Accept
```julia
# Simple Send and Accept

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

@process lock() begin
    while true
        @accept caller lock()
        @accept caller unlock()
    end
end

the_lock = Nothing

@process p1(i::Integer) begin
    println("$(current_time()): Process p1($i) started")
    @send the_lock lock()
    println("$(current_time()): Process p1($i) acquired lock")
    work(rand(Uniform(1.0, 10.0)))
    println("$(current_time()): Process p1($i) released lock")
    @send the_lock unlock()
    println("$(current_time()): Process p1($i) ended")
end

function run_simulation(n::Integer)
    @simulation begin
        # current_trace!(true)
        global the_lock = @schedule now lock()
        for i = 1:n
            @schedule at rand(Uniform(0.0, 10.0)) p1(i)
        end
        start_simulation()
    end
end

run_simulation(10)

```
## Tally-And-Accumulate
```julia
# Tally and Accumulate

using SimLynx
SimLynx.greet()

tallied = nothing
accumulated = nothing

@process test_process(value_durations) begin
    for (value, duration) in value_durations
        tallied.value = value
        accumulated.value = value
        work(duration)
    end
end

function main(value_durations)
    println("--- Test Tally and Accumulate ---")
    @simulation begin
        # Create tallied and accumulated variables
        global tallied = Variable{Int64}(data=:tally, history=true)
        global accumulated = Variable{Int64}(0, history=true)
        # Schedule the test process and start the simulation
        @schedule at 0.0 test_process(value_durations)
        start_simulation()
        # Print and plot the tallied results
        println("--- Tally ---")
        print_stats(tallied, title="Tallied Statistics")
        plot_history(tallied, title="Tallied History")
        # Print and plot the accumulated results
        println("--- Accumulate ---")
        print_stats(accumulated, title="Accumulated Statistics")
        plot_history(accumulated, title="Accumulated History")
    end
end

main([(1, 2.0), (2, 1.0), (3, 2.0), (4, 3.0)])

```
## Test-Scheduling
```julia
# Test Scheduling

using SimLynx
SimLynx.greet()

@event test_process(i) begin
    println("$(current_time()): Event $i occurred")
end

function main()
    println("--- Test Scheduling ---")
    println("The events should execute in order.")
    @simulation begin
        # Future events
        @schedule at 0.0 test_process(4)
        @schedule at 0.0 test_process(5)
        @schedule at 0.5 test_process(7)
        @schedule at 2.0 test_process(9)
        @schedule at 1.0 test_process(8)
        @schedule in 0.0 test_process(6)
        @schedule in 2.0 test_process(10)
        # Now events
        @schedule now test_process(2)
        @schedule now test_process(3)
        @schedule immediate test_process(1)
        start_simulation()
    end
end

main()

```
## Trace-Event-Based-Bank-Model
```julia
# SimLynx.jl Event-Based Discrete-Event Simulation Example

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

const N_TELLERS = 2
const MEAN_INTERARRIVAL_TIME = 4.0
const MIN_SERVICE_TIME = 2.0
const MAX_SERVICE_TIME = 10.0

struct Customer
    id::Int64
    Customer(id::Int64) = new(id)
end

Base.show(io::IO, customer::Customer) =
    print(io, "Customer($(customer.id))")

mutable struct Teller
    id::Int64
    serving::Union{Customer, Nothing}
    Teller(id::Int64) = new(id, nothing)
end

Base.show(io::IO, teller::Teller) =
    print(io, "Teller($(teller.id))")

tellers = nothing
teller_queue = nothing

function available_teller()::Union{Teller, Nothing}
    for teller in tellers
        if isnothing(teller.serving)
            return teller
        end
    end
    return nothing
end

generator_dist = Exponential(MEAN_INTERARRIVAL_TIME)

@event generate(i::Integer, n::Integer) begin
    @schedule now arrival(Customer(i))
    if i < n
        @schedule in rand(generator_dist) generate(i + 1, n)
    end
end

@event arrival(customer::Customer) begin
    teller = available_teller()
    if isnothing(teller)
        enqueue!(teller_queue, customer)
    else
        @schedule now service(teller, customer)
    end
end

@event service(teller::Teller, customer::Customer) begin
    dist = Uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
    teller.serving = customer
    @schedule in rand(dist) departure(teller, customer)
end

@event departure(teller::Teller, customer::Customer) begin
    if isempty(teller_queue)
        teller.serving = nothing
    else
        next_customer = dequeue!(teller_queue)
        teller.serving = next_customer
        @schedule now service(teller, next_customer)
    end
end

function run_simulation(n::Integer)
    @assert n > 0
    println("SimLynx.jl Event-Based Discrete-Event Simulation Example")
    println("$N_TELLERS Teller, Single Queue Bank Model")
    println("  Inter-arrival time = Exponential($MEAN_INTERARRIVAL_TIME)")
    println("  Service time = Uniform($MIN_SERVICE_TIME, $MAX_SERVICE_TIME)")
    println("  Number of customers = $n")
    @simulation begin
        global tellers = [Teller(i) for i = 1:N_TELLERS]
        global teller_queue = FifoQueue{Customer}()
        current_trace!(true)
        @schedule at 0.0 generate(1, n)
        start_simulation()
        print_stats(teller_queue.n, title="Teller Queue Length Statistics")
        plot_history(teller_queue.n, title="Teller Queue Length History")
    end
end

run_simulation(10)

```
## Trace-Mixed-Event-Process-Based-Bank-Model
```julia
# mixed-event-process-based-bank-model.jl
# SimLynx.jl Mixed Event and Process Based Simulation Model

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

const N_TELLERS = 2
const MEAN_INTERARRIVAL_TIME = 4.0
const MIN_SERVICE_TIME = 2.0
const MAX_SERVICE_TIME = 10.0

tellers = nothing

generator_dist = Exponential(MEAN_INTERARRIVAL_TIME)

"Generate the ith customer and schedule the next arrival."
@event generate(i:: Integer, n::Integer) begin
    @schedule now customer(i)
    if i < n
        @schedule in rand(generator_dist) generate(i + 1, n)
    end
end

"The ith customer into the system."
@process customer(i::Integer) begin
    dist = Uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
    @with_resource tellers begin
        work(rand(dist))
    end
end

"Run the simulation."
function run_simulation(n::Integer)
    @assert n > 0
    println("SimLynx Mixed Event and Process Based Simulation Example")
    println("$N_TELLERS Teller, Single Queue Bank Model")
    println("  Inter-arrival time = Exponential($MEAN_INTERARRIVAL_TIME)")
    println("  Service time = Uniform($MIN_SERVICE_TIME, $MAX_SERVICE_TIME)")
    println("  Number of customers = $n")
    @simulation begin
        current_trace!(true)
        global tellers = Resource(N_TELLERS, "tellers")
        @schedule at 0.0 generate(1, n)
        start_simulation()
        print_stats(tellers.allocated, title="Allocated Statistics")
        print_stats(tellers.queue_length, title="Queue Length Statistics")
        plot_history(tellers.queue_length, title="Queue Length History")
    end
end

run_simulation(10)

```
## Trace-Process-Based-Bank-Model
```julia
# SimLynx.jl Process-Based Discrete-Event Simulation Example

#=
This is a simple process-based discrete-event simulation of an N teller, single
queue bank.

There are two (2) processes:
    generator(n::Integer)
      Generates n arrivals into the system with exponentially distributed
      inter-arrival time with a mean of 4.0.
    customer(i::Integer)
      The process representing the ith customer in the system. Each customer
      acquires a teller and works a uniformly distributed time between 2.0 and
      10.0. It then releases the teller and exits.

There is a single resource, tellers, that represents the tellers in the bank.
The number if tellers is set by the N_TELLERS global variable.

Once the simulation runs, statistics are printed for the tellers allocation and
queue length as well as a plot of the queue length over time.
=#

using SimLynx
SimLynx.greet()

using Distributions: Exponential, Uniform
using Random

const N_TELLERS = 2
const MEAN_INTERARRIVAL_TIME = 4.0
const MIN_SERVICE_TIME = 2.0
const MAX_SERVICE_TIME = 10.0

tellers = nothing

"Process to generate n customers arriving into the system."
@process generator(n::Integer) begin
    dist = Exponential(MEAN_INTERARRIVAL_TIME)
    for i = 1:n
        @schedule now customer(i)
        if i < n
            work(rand(dist))
        end
    end
end

"The ith customer into the system."
@process customer(i::Integer) begin
    dist = Uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
    @with_resource tellers begin
        work(rand(dist))
    end
end

"Run the simulation for n customers."
function run_simulation(n::Integer)
    println("SimLynx.jl Process-Based Discrete-Event Simulation Example")
    println("$N_TELLERS Teller, Single Queue Bank Model")
    println("  Inter-arrival time = Exponential($MEAN_INTERARRIVAL_TIME)")
    println("  Service time = Uniform($MIN_SERVICE_TIME, $MAX_SERVICE_TIME)")
    println("  Number of customers = $n")
    @simulation begin
        global tellers = Resource(N_TELLERS, "tellers")
        current_trace!(true)
        @schedule at 0.0 generator(n)
        start_simulation()
        println("--- Simulation results after $(current_time()) minutes ---")
        print_stats(tellers.allocated, title="Teller Allocation Statistics")
        print_stats(tellers.queue_length, title="Teller Queue Length Statistics")
        plot_history(tellers.queue_length, title="Teller Queue Length History")
        print_stats(tellers.wait, title="Teller Queue Wait Time Statistics")
        plot_history(tellers.wait, title="Teller Queue Wait Time History")
    end
end

run_simulation(10)

```