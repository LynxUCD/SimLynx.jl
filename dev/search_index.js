var documenterSearchIndex = {"docs":
[{"location":"examples/","page":"Examples","title":"Examples","text":"    # NOTE this file is autogenerated, do not edit examples.md directly. To make an example, upload the .jl file to the examples folder. Header comments may be included at the top of the file using \"\"\" syntax","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The code for these examples can also be found on Github  in the docs/examples folder.","category":"page"},{"location":"examples/#Event-Based","page":"Examples","title":"Event Based","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"\"\"\"\r\nThis is a simple process-based discrete-event simulation of an N teller, single\r\nqueue bank.\r\n\r\nThere are two (2) processes:\r\n    generator(n::Integer)\r\n      Generates n arrivals into the system with exponentially distributed\r\n      inter-arrival time with a mean of 4.0.\r\n    customer(i::Integer)\r\n      The process representing the ith customer in the system. Each customer\r\n      acquires a teller and works a uniformly distributed time between 2.0 and\r\n      10.0. It then releases the teller and exits.\r\n\r\nThere is a single resource, tellers, that represents the tellers in the bank.\r\nThe number if tellers is set by the N_TELLERS global variable.\r\n\r\nOnce the simulation runs, statistics are printed for the tellers allocation and\r\nqueue length as well as a plot of the queue length over time.\r\n\"\"\"\r\nusing SimLynx\r\n\r\nusing Distributions\r\nusing Random\r\n\r\nconst N_TELLERS = 2\r\nconst N_CUSTOMERS = 10\r\n\r\nstruct Customer\r\n    id::Int64\r\n    Customer(id::Int64) = new(id)\r\nend\r\n\r\nBase.show(io::IO, customer::Customer) =\r\n    print(io, \"Customer($(customer.id))\")\r\n\r\nmutable struct Teller\r\n    id::Int64\r\n    serving::Union{Customer, Nothing}\r\n    Teller(id::Int64) = new(id, nothing)\r\nend\r\n\r\nBase.show(io::IO, teller::Teller) =\r\n    print(io, \"Teller($(teller.id))\")\r\n\r\ntellers = nothing\r\nteller_queue = nothing\r\n\r\nfunction available_teller()::Union{Teller, Nothing}\r\n    for teller in tellers\r\n        if isnothing(teller.serving)\r\n            return teller\r\n        end\r\n    end\r\n    return nothing\r\nend\r\n\r\n@event generate(i::Integer) begin\r\n    if i <= N_CUSTOMERS\r\n        @schedule now arrival(Customer(i))\r\n        @schedule in rand(Distributions.Exponential(4.0)) generate(i + 1)\r\n    end\r\nend\r\n\r\n@event arrival(customer::Customer) begin\r\n    println(\"$(current_time()): $customer arrives\")\r\n    teller = available_teller()\r\n    if isnothing(teller)\r\n        enqueue!(teller_queue, customer)\r\n    else\r\n        @schedule now service(teller, customer)\r\n    end\r\nend\r\n\r\n@event service(teller::Teller, customer::Customer) begin\r\n    println(\"$(current_time()): $teller starts servicing $customer\")\r\n    teller.serving = customer\r\n    @schedule in rand(Distributions.Uniform(2.0, 10.0)) departure(teller, customer)\r\nend\r\n\r\n@event departure(teller::Teller, customer::Customer) begin\r\n    println(\"$(current_time()): $teller finishes servicing $customer\")\r\n    if isempty(teller_queue)\r\n        teller.serving = nothing\r\n    else\r\n        next_customer = dequeue!(teller_queue)\r\n        teller.serving = next_customer\r\n        @schedule now service(teller, customer)\r\n    end\r\nend\r\n\r\nfunction main()\r\n    @with_new_simulation begin\r\n        global tellers = [Teller(i) for i = 1:N_TELLERS]\r\n        global teller_queue = FifoQueue{Customer}()\r\n        @schedule at 0.0 generate(1)\r\n        println(\"Hello world?\")\r\n        start_simulation()\r\n        print_stats(teller_queue.n)\r\n        plot_history(teller_queue.n, \"event_based.png\")\r\n    end\r\nend\r\n\r\nmain()\r\n","category":"page"},{"location":"examples/#Example-1","page":"Examples","title":"Example-1","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"\"\"\"\r\nA simple implementation of an event-based simulation. This program simulates a bank.\r\n\"\"\"\r\nusing SimLynx\r\n\r\nusing Distributions: Exponential, Uniform\r\nusing Random\r\n\r\nconst N_TELLERS = 2\r\ntellers = nothing\r\n\r\n\"Process to generate n customers arriving into the system.\"\r\n@process generator(n::Integer) begin\r\n    for i = 1:n\r\n        work(rand(Exponential(4.0)))\r\n        @schedule now customer(i)\r\n    end\r\nend\r\n\r\n\"The ith customer into the system.\"\r\n@process customer(i::Integer) begin\r\n    dist = Uniform(2.0, 10.0)\r\n    @with_resource tellers begin\r\n        work(rand(dist))\r\n    end\r\nend\r\n\r\n\"Run the simulation for n customers.\"\r\nfunction run_simulation(n::Integer)\r\n    @with_new_simulation begin\r\n        global tellers = Resource(N_TELLERS, \"tellers\")\r\n        @schedule at 0.0 generator(n)\r\n        start_simulation()\r\n        print_stats(tellers.allocated, \"Allocated Statistics\")\r\n        print_stats(tellers.queue_length, \"Queue Length Statistics\")\r\n        plot_history(tellers.queue_length, \"queue_length.png\",\r\n            \"Queue Length History\")\r\n    end\r\nend\r\n\r\nrun_simulation(100)\r\n","category":"page"},{"location":"examples/#Example-2","page":"Examples","title":"Example-2","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"\"\"\"\r\nLike example-1.jl but using @event instead of @process for the generate\r\nfunctionality. Also uses the (experimental) trace functionality.\r\n\r\nTo Do:\r\n--- (1)\r\nWe get the following error when we use\r\n'using Distributions: Exponential, Uniform'\r\nbut not when we use\r\n'using Distributions'\r\n\r\nERROR: LoadError: TaskFailedException:\r\nUndefVarError: Distributions not defined\r\nStacktrace:\r\n [1] macro expansion at C:\\Users\\doug\\Develop\\SimLynx\\example-2.jl:23 [inlined]\r\n [2] (::var\"#26#28\"{Int64})() at C:\\Users\\doug\\Develop\\SimLynx\\SimLynx.jl:41\r\n [3] start_simulation() at C:\\Users\\doug\\Develop\\SimLynx\\SimLynx.jl:349\r\n [4] macro expansion at C:\\Users\\doug\\Develop\\SimLynx\\example-2.jl:41 [inlined]\r\n [5] macro expansion at C:\\Users\\doug\\Develop\\SimLynx\\SimLynx.jl:246 [inlined]\r\n [6] (::var\"#33#34\")() at .\\task.jl:356\r\nStacktrace:\r\n [1] wait at .\\task.jl:267 [inlined]\r\n [2] macro expansion at C:\\Users\\doug\\Develop\\SimLynx\\SimLynx.jl:251 [inlined]\r\n [3] run_simulation() at C:\\Users\\doug\\Develop\\SimLynx\\example-2.jl:37\r\n [4] top-level scope at C:\\Users\\doug\\Develop\\SimLynx\\example-2.jl:49\r\n [5] include_string(::Function, ::Module, ::String, ::String) at .\\loading.jl:1088\r\nin expression starting at C:\\Users\\doug\\Develop\\SimLynx\\example-2.jl:49\r\n--- (1)\r\n\"\"\"\r\n\r\nusing SimLynx\r\n\r\nusing Distributions\r\nusing Random\r\n\r\nconst N_TELLERS = 2\r\nconst N_CUSTOMERS = 10\r\n\r\ntellers = nothing\r\n\r\n\"Generate the ith customer and schedule the next arrival.\"\r\n@event generate(i::Integer) begin\r\n    if i <= N_CUSTOMERS\r\n        @schedule now customer(i)\r\n        @schedule in rand(Distributions.Exponential(4.0)) generate(i + 1)\r\n    end\r\nend\r\n\r\n\"The ith customer into the system.\"\r\n@process customer(i::Integer) begin\r\n    dist = Distributions.Uniform(2.0, 10.0)\r\n    @with_resource tellers begin\r\n        work(rand(dist))\r\n    end\r\nend\r\n\r\n\"Run the simulation.\"\r\nfunction run_simulation()\r\n    @with_new_simulation begin\r\n        current_trace!(true)\r\n        global tellers = Resource(N_TELLERS, \"tellers\")\r\n        @schedule at 0.0 generate(1)\r\n        start_simulation()\r\n        print_stats(tellers.allocated, \"Allocated Statistics\")\r\n        print_stats(tellers.queue_length, \"Queue Length Statistics\")\r\n        plot_history(tellers.queue_length, \"queue_length.png\",\r\n            \"Queue Length History\")\r\n    end\r\nend\r\n\r\nrun_simulation()\r\n","category":"page"},{"location":"examples/#Example-3","page":"Examples","title":"Example-3","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"\"\"\"\r\nThis example demonstrates nested simulations, which is used to run multiple\r\nsimulation runs to gather statistics (e.g., distributions) across the runs. This\r\nexample just executes the multiple runs without gathering additional data.\r\n\"\"\"\r\n\r\nusing SimLynx\r\n\r\nusing Distributions: Exponential, Uniform\r\nusing Random\r\n\r\nconst N_TELLERS = 2\r\ntellers = nothing\r\n\r\n\"Process to generate n customers arriving into the system.\"\r\n@process generator(n::Integer) begin\r\n    dist = Exponential(4.0)\r\n    for i = 1:n\r\n        work(rand(dist))\r\n        @schedule now customer(i)\r\n    end\r\nend\r\n\r\n\"The ith customer into the system.\"\r\n@process customer(i::Integer) begin\r\n    dist = Uniform(2.0, 10.0)\r\n    @with_resource tellers begin\r\n        work(rand(dist))\r\n    end\r\nend\r\n\r\n\"Run the simulation for n customers.\"\r\nfunction run_simulation(n::Integer)\r\n    @with_new_simulation begin\r\n        for i = 1:10\r\n            @with_new_simulation begin\r\n                global tellers = Resource(N_TELLERS, \"tellers\")\r\n                @schedule at 0.0 generator(n)\r\n                start_simulation()\r\n                print_stats(tellers.allocated, \"Allocated Statistics\")\r\n                print_stats(tellers.queue_length, \"Queue Length Statistics\")\r\n                plot_history(tellers.queue_length, \"queue_length.png\",\r\n                    \"Queue Length History\")\r\n                print_stats(tellers.wait, \"Queue Wait Statistics\")\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\nrun_simulation(1_000)\r\n","category":"page"},{"location":"examples/#Example-4","page":"Examples","title":"Example-4","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"\"\"\"\r\nExample nested simulation models with data collection\r\n\"\"\"\r\n\r\nusing SimLynx\r\n\r\nusing Distributions: Exponential, Uniform\r\nusing Random\r\n\r\nconst N_TELLERS = 2\r\ntellers = nothing\r\n\r\n\"Process to generate n customers arriving into the system.\"\r\n@process generator(n::Integer) begin\r\n    dist = Exponential(4.0)\r\n    for i = 1:n\r\n        work(rand(dist))\r\n        @schedule now customer(i)\r\n    end\r\nend\r\n\r\n\"The ith customer into the system.\"\r\n@process customer(i::Integer) begin\r\n    @with_resource tellers begin\r\n        work(rand(Uniform(2.0, 10.0)))\r\n    end\r\nend\r\n\r\n\"Run the simulation for n customers.\"\r\nfunction run_simulation(n₁::Integer, n₂::Integer)\r\n    @with_new_simulation begin\r\n        avg_wait = Variable{Float64}(data=:tally, history=true)\r\n        for i = 1:n₁\r\n            @with_new_simulation begin\r\n                global tellers = Resource(N_TELLERS, \"tellers\")\r\n                @schedule at 0.0 generator(n₂)\r\n                start_simulation()\r\n                set!(avg_wait, mean(tellers.wait.stats))\r\n            end\r\n        end\r\n        print_stats(avg_wait)\r\n        plot_history(avg_wait, \"avg-weight.png\")\r\n    end\r\nend\r\n\r\n@time run_simulation(10_000, 1_000)\r\n","category":"page"},{"location":"examples/#Example-5","page":"Examples","title":"Example-5","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"\"\"\"\r\nThis is an example on an open-loop simulation model. This example gathers\r\nstatistics on the maximum number of tellers needed for no customer waiting.\r\n\"\"\"\r\n\r\nusing SimLynx\r\n\r\nusing Distributions: Exponential, Uniform\r\nusing Random\r\n\r\nconst N_TELLERS = 2\r\ntellers = nothing\r\n\r\n\"Process to generate n customers arriving into the system.\"\r\n@process generator(n::Integer) begin\r\n    dist = Exponential(4.0)\r\n    for i = 1:n\r\n        work(rand(dist))\r\n        @schedule now customer(i)\r\n    end\r\nend\r\n\r\n\"The ith customer into the system.\"\r\n@process customer(i::Integer) begin\r\n    @with_resource tellers begin\r\n        work(rand(Uniform(2.0, 10.0)))\r\n    end\r\nend\r\n\r\n\"Run the simulation for n customers.\"\r\nfunction run_simulation(n₁::Integer, n₂::Integer)\r\n    @with_new_simulation begin\r\n        max_tellers = Variable{Int64}(data=:tally, history=true)\r\n        for i = 1:n₁\r\n            @with_new_simulation begin\r\n                global tellers = Resource(\"tellers\")\r\n                @schedule at 0.0 generator(n₂)\r\n                start_simulation()\r\n                sync!(tellers.allocated)\r\n                set!(max_tellers, tellers.allocated.stats.max)\r\n            end\r\n        end\r\n        print_stats(max_tellers)\r\n        plot_history(max_tellers, \"max_tellers.png\")\r\n    end\r\nend\r\n\r\n@time run_simulation(10_000, 1_000)\r\n","category":"page"},{"location":"examples/#Harbor-Model","page":"Examples","title":"Harbor Model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"\"\"\"\r\nThe Harbor Model is an example simulation that leverages the resume, suspend, and interrupt methods of SimLynx.\r\n\"\"\"\r\nusing SimLynx\r\n\r\nusing Distributions: Exponential, Uniform\r\nusing Random\r\n\r\ncycle_time = nothing\r\n\r\ndock = nothing\r\nqueue = nothing\r\n\r\n@process scheduler() begin\r\n    i = 1\r\n    while true\r\n        @schedule in 0.0 ship(i)\r\n        work(rand(Exponential(4.0 / 3.0)))\r\n        i += 1\r\n    end\r\nend\r\n\r\n@process ship(i::Integer) begin\r\n    arrival_time = current_time()\r\n    current_process_store(:unloading_time, rand(Uniform(1.0, 2.5)))\r\n    if !harbor_master(current_process(), :arriving)\r\n        enqueue!(queue, current_process())\r\n        suspend()\r\n    end\r\n    work(current_process_store(:unloading_time))\r\n    remove(dock, current_process())\r\n    set!(cycle_time, current_time() - arrival_time)\r\n    harbor_master(current_process(), :leaving)\r\n    return nothing\r\nend\r\n\r\nfunction harbor_master(ship::Process, action::Symbol)\r\n    if action == :arriving\r\n        if length(dock.data) < 2\r\n            # The dock is not full\r\n            if isempty(dock)\r\n                process_store(ship,\r\n                              :unloading_time,\r\n                              process_store(ship, :unloading_time) / 2)\r\n            else\r\n                other_ship = first(dock)\r\n                notice = interrupt(other_ship)\r\n                notice.time = current_time() + 2*notice.time\r\n                resume(other_ship, notice)\r\n            end\r\n            enqueue!(dock, ship)\r\n            return true\r\n        else\r\n            # The dock is full\r\n            return false\r\n        end\r\n    elseif action == :leaving\r\n        if isempty(queue)\r\n            if !isempty(dock)\r\n                other_ship = first(dock)\r\n                notice = interrupt(other_ship)\r\n                notice.time = current_time() + 2/notice.time\r\n                resume(other_ship, notice)\r\n            end\r\n        else\r\n            next_ship = dequeue!(queue)\r\n            enqueue!(dock, next_ship)\r\n            resume(next_ship, Notice(current_time(), next_ship))\r\n        end\r\n        return true\r\n    else\r\n        error(\"harbor_master: illegal action value $action\")\r\n    end\r\nend\r\n\r\n@event stop_sim() begin\r\n    println(\"Harbor Model - report after $(current_time()) - $(cycle_time.stats.n)\")\r\n    println(\"Minimum unload time was $(cycle_time.stats.min)\")\r\n    println(\"Maximum unload time was $(cycle_time.stats.max)\")\r\n    println(\"Average unload time was $(cycle_time.stats.max)\")\r\n    println(\"Average queue of ships waiting to be unloaded was $(mean(queue.n.stats))\")\r\n    println(\"Maximum queue of ships waiting to be unloaded was $(queue.n.stats.max)\")\r\n    plot_history(queue.n, \"harbor-history.png\")\r\n    stop_simulation()\r\nend\r\n\r\nfunction run_simulation()\r\n    @with_new_simulation begin\r\n        # current_trace!(true)\r\n        global cycle_time = Variable{Float64}(data=:tally)\r\n        global dock = FifoQueue{Process}()\r\n        global queue = FifoQueue{Process}()\r\n        @schedule at 0.0 scheduler()\r\n        @schedule at 80.0 stop_sim()\r\n        start_simulation()\r\n    end\r\nend\r\n\r\nrun_simulation()\r\n","category":"page"},{"location":"examples/#Tally-And-Accumulate","page":"Examples","title":"Tally-And-Accumulate","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"\"\"\"\r\nExample usage of the test and accumulate functionality of SimLynx\r\n\"\"\"\r\nusing SimLynx\r\n\r\ntallied = nothing\r\naccumulated = nothing\r\n\r\n@process test_process(value_durations) begin\r\n    for (value, duration) in value_durations\r\n        set!(tallied, value)\r\n        set!(accumulated, value)\r\n        work(duration)\r\n    end\r\nend\r\n\r\nfunction main(value_durations)\r\n    @with_new_simulation begin\r\n        global tallied = Variable{Int64}(data=:tally, history=true)\r\n        global accumulated = Variable{Int64}(0, history=true)\r\n        @schedule at 0.0 test_process(value_durations)\r\n        start_simulation()\r\n        println(\"--- Test Tally and Accumulate ---\")\r\n        println(\"--- Tally ---\")\r\n        println(\"N    = $(tallied.stats.n)\")\r\n        println(\"Sum  = $(tallied.stats.sum)\")\r\n        println(\"Mean = $(mean(tallied.stats))\")\r\n        plot_history(tallied, \"tallied.png\", \"Tallied History\")\r\n        println(\"--- Accumulate ---\")\r\n        sync!(accumulated) # Retrieving slots does not sync\r\n        println(\"N    = $(accumulated.stats.n)\")\r\n        println(\"Sum  = $(accumulated.stats.sum)\")\r\n        println(\"Mean = $(mean(accumulated.stats))\")\r\n        plot_history(accumulated, \"accumulated.png\", \"Accumulated History\")\r\n    end\r\nend\r\n\r\nmain([(1, 2.0), (2, 1.0), (3, 2.0), (4, 3.0)])\r\n","category":"page"},{"location":"#SimLynx.jl-Documentation","page":"Home","title":"SimLynx.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimLynx.jl is a Julia Library that provides a Hybrid Simulation Engine and Language in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SimLynx","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SimLynx]","category":"page"},{"location":"#SimLynx.current_simulation","page":"Home","title":"SimLynx.current_simulation","text":"The current active simulation.\n\n\n\n\n\n","category":"constant"},{"location":"#SimLynx.Allocation","page":"Home","title":"SimLynx.Allocation","text":"A (unit) allocation of the resource to a process.\n\n\n\n\n\n","category":"type"},{"location":"#SimLynx.Notice","page":"Home","title":"SimLynx.Notice","text":"A notice represents the execution of an event at some (simulated) future time.\n\n\n\n\n\n","category":"type"},{"location":"#SimLynx.Resource","page":"Home","title":"SimLynx.Resource","text":"A sharable resource with a fixed number of allocatable units. The queue maintains a list of processes waiting for the resource.\n\n\n\n\n\n","category":"type"},{"location":"#SimLynx.Simulation","page":"Home","title":"SimLynx.Simulation","text":"A simulation represents the state of an execution. Specifically, it contains the current time, current event, future event list, and control task for the simulation.\n\n\n\n\n\n","category":"type"},{"location":"#SimLynx.Variable","page":"Home","title":"SimLynx.Variable","text":"A variable automatically maintains the history and statistics of its value over time.\n\n\n\n\n\n","category":"type"},{"location":"#Base.get-Tuple{SimLynx.Variable}","page":"Home","title":"Base.get","text":"Return the current value of a variable.\n\n\n\n\n\n","category":"method"},{"location":"#Base.schedule-Tuple{Notice}","page":"Home","title":"Base.schedule","text":"schedule(notice::Notice)\nschedule(sim::Simulation, notice::Notice)\n\nSchedule the notice on the future event list for the specified simulation, which defaults to the current simulation.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.allocate-Tuple{SimLynx.Resource,Process}","page":"Home","title":"SimLynx.allocate","text":"Allocate a unit of the resource to a process.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.deallocate-Tuple{SimLynx.Resource,Process}","page":"Home","title":"SimLynx.deallocate","text":"Deallocate a unit of the resource from a process.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.event_schedule-Tuple{Notice,Array{Notice,1}}","page":"Home","title":"SimLynx.event_schedule","text":"event_schedule(notice::Notice, event_list::Array{Notice, 1})\n\nAdd a notice to the given event list. This routine keeps the event list in sorted (ascending) order.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.interrupt-Tuple{Process}","page":"Home","title":"SimLynx.interrupt","text":"Interrupt the execution of a waiting process.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.islessorequal-Tuple{Notice,Notice}","page":"Home","title":"SimLynx.islessorequal","text":"Ascending order function for event lists.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.print_stats","page":"Home","title":"SimLynx.print_stats","text":"Print the accumulates statistics for a variable.\n\n\n\n\n\n","category":"function"},{"location":"#SimLynx.release-Tuple{SimLynx.Resource}","page":"Home","title":"SimLynx.release","text":"release(resource::Resource)\n\nRelease a unit of the resource. If there are process queued for the resource, then allocate a unit of the resource to the longest waiting process. Note that this works for unit allocations.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.request-Tuple{SimLynx.Resource}","page":"Home","title":"SimLynx.request","text":"request(resource::Resource)\n\nRequest a unit of the resource. If a unit of the resource is not available, then queue the request.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.resume-Tuple{Process,Notice}","page":"Home","title":"SimLynx.resume","text":"Resume the execution of a suspended or interrupted process.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.set!-Tuple{SimLynx.Variable,Any}","page":"Home","title":"SimLynx.set!","text":"Set the value of a variable.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.start_simulation-Tuple{}","page":"Home","title":"SimLynx.start_simulation","text":"start_simulation()\n\nThis is the main simulation loop.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.suspend-Tuple{}","page":"Home","title":"SimLynx.suspend","text":"Suspend the execution of the current process.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.sync!-Tuple{SimLynx.Variable}","page":"Home","title":"SimLynx.sync!","text":"Synchronize the history and statistics for a variable. This is called before the value of a variable is changed, via set!, and before the history or statistics are used.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.update!-Union{Tuple{T}, Tuple{SimLynx.AccumulatedStats{T},T,Float64}} where T<:Real","page":"Home","title":"SimLynx.update!","text":"Accumulate running statistics over a time duration.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.update!-Union{Tuple{T}, Tuple{SimLynx.TalliedStats{T},T}} where T<:Real","page":"Home","title":"SimLynx.update!","text":"Tally running statistics.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.work-Tuple{Real}","page":"Home","title":"SimLynx.work","text":"work(delay::Real)\n\nSimulate the delay while work is being done.  Add an event to return to this task in the future to the event list.\n\n\n\n\n\n","category":"method"},{"location":"#SimLynx.@event-Tuple{Any,Any}","page":"Home","title":"SimLynx.@event","text":"@event <sig> begin\n    <body>\nend\n\nDefine a simulation event with the specified signature and implemented by the given body.\n\n\n\n\n\n","category":"macro"},{"location":"#SimLynx.@process-Tuple{Any,Any}","page":"Home","title":"SimLynx.@process","text":"@process <sig> begin\n    <body>\nend\n\nDefine a simulation process with the specified signature and implemented by the given body.\n\n\n\n\n\n","category":"macro"},{"location":"#SimLynx.@schedule-Tuple{Symbol,Expr}","page":"Home","title":"SimLynx.@schedule","text":"@schedule now <expr>\n@schedule at <time> <expr>\n@schedule in <delta> <expr>\n\nSchedule an event to occur in the future. The create an event and adds it to the future event list at the specified time.\n\n\n\n\n\n","category":"macro"},{"location":"#SimLynx.@thunk-Tuple{Any}","page":"Home","title":"SimLynx.@thunk","text":"@thunk ex\n\nReturn a thunk (i.e., a function with no arguments) that executes the expression when called.\n\n\n\n\n\n","category":"macro"},{"location":"#SimLynx.@with_new_simulation-Tuple{Any}","page":"Home","title":"SimLynx.@with_new_simulation","text":"@with_new_simulation begin\n    <body>\nend\n\nExecutes the body within a new simulation environment. This is the easiest way to ensure a clean simulation environment.\n\n\n\n\n\n","category":"macro"},{"location":"#SimLynx.@with_resource-Tuple{Any,Any}","page":"Home","title":"SimLynx.@with_resource","text":"@with_resource resource begin\n    body\nend\n\nWrap the body in a request / release pair for the resource.\n\n\n\n\n\n","category":"macro"}]
}
